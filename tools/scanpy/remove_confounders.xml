<tool id="scanpy_remove_confounders" name="Remove confounders" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@profile@">
    <description>with scanpy</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="bio_tools"/>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
      ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_imports@
@CMD_read_inputs@

#if $method.method == "pp.regress_out"
sc.pp.regress_out(
   adata=adata,
   #if $method.layer != ''
   layer='$method.layer',
   #end if
   #set $keys = [str(x.strip()) for x in str($method.keys).split(',')]
   keys=$keys,
   n_jobs = int(os.getenv("GALAXY_SLOTS", 4)),
   copy=False)

#else if $method.method == "external.pp.mnn_correct"
    #for i, filepath in enumerate($methods.extra_adata)
adata_$i = ad.read('$filepath')
    #end for

sc.external.pp.mnn_correct(
    adata,
    #for i, filepath in enumerate($methods.extra_adata)
    adata_$i,
    #end for
    #if $methods.var_subset
    #set $var_subset=([x.strip() for x in str($method.var_subset).split(',')])
    var_subset=$var_subset,
    #end if
    batch_key='$method.batch_key',
    index_unique='$method.index_unique'
    #if $methods.batch_categories
    #set $batch_categories=([x.strip() for x in str($method.batch_categories).split(',')])
    batch_categories=$batch_categories,
    #end if
    k=$method.k,
    sigma=$method.sigma,
    cos_norm_in=$method.cos_norm_in,
    cos_norm_out=$method.cos_norm_out,
    svd_dim=$method.svd_dim,
    var_adj=$method.var_adj,
    compute_angle=$method.compute_angle,
    mnn_order='$method.mnn_order',
    svd_mode='$method.svd_mode',
    do_concatenate=True,
    save_raw=True,
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4)))

#else if $method.method == "pp.combat"
sc.pp.combat(
    adata,
    key='$method.key',
    inplace=True)

#else if $method.method == "pp.scrublet"
sc.pp.scrublet(
    adata,
    #if $method.batch_key != ''
    batch_key='$method.batch_key',
    #end if
    sim_doublet_ratio=$method.sim_doublet_ratio,
    expected_doublet_rate=$method.expected_doublet_rate,
    stdev_doublet_rate=$method.stdev_doublet_rate,
    synthetic_doublet_umi_subsampling=$method.synthetic_doublet_umi_subsampling,
    knn_dist_metric='$method.knn_dist_metric',
    normalize_variance=$method.normalize_variance,
    log_transform=$method.log_transform,
    mean_center=$method.mean_center,
    n_prin_comps=$method.n_prin_comps,
    use_approx_neighbors=$method.use_approx_neighbors,
    get_doublet_neighbor_parents=$method.get_doublet_neighbor_parents,
    n_neighbors=$method.n_neighbors,
    #if str($method.threshold) != ''
    threshold=$method.threshold,
    #end if
    random_state=$method.random_state,
    inplace=True)

#end if

@CMD_anndata_write_outputs@
]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="inputs_anndata"/>
        <conditional name="method">
            <param argument="method" type="select" label="Method used for plotting">
                <option value="pp.regress_out">Regress out unwanted sources of variation, using 'pp.regress_out'</option>
                <option value="external.pp.mnn_correct">Correct batch effects by matching mutual nearest neighbors, using 'pp.mnn_correct'</option>
                <option value="pp.combat">Correct batch effects with ComBat function, using 'pp.combat'</option>
                <option value="pp.scrublet">Predict doublets using 'pp.scrublet'</option>
            </param>
            <when value="pp.regress_out">
                <param argument="layer" type="text" value="" label="Which element of layers to regress on">
                    <expand macro="sanitize_query"/>
                </param>
                <param argument="keys" type="text" value="" label="Keys for observation annotation on which to regress on" help="Keys separated by a comma">
                    <expand macro="sanitize_query" />
                </param>
            </when>
            <when value="external.pp.mnn_correct">
                <param name="extra_adata" type="data" multiple="true" optional="true" format="h5ad" label="Extra annotated data matrix" help="They should have same number of variables."/>
                <param argument="var_subset" type="text" value="" optional="true" label="The subset of vars to be used when performing MNN correction" help="List of comma-separated key from '.var_names'. If not set, all vars are used">
                    <expand macro="sanitize_query" />
                </param>
                <param argument="batch_key" type="text" value="batch" label="Batch key for the concatenate">
                    <expand macro="sanitize_query" />
                </param>
                <param name="index_unique" type="select" label="Separator to join the existing index names with the batch category" help="Leave it empty to keep existing indices">
                    <option value="-">-</option>
                    <option value="_">_</option>
                    <option value=" "> </option>
                    <option value="/">/</option>
                </param>
                <param argument="batch_categories" type="text" value="" optional="true" label="Batch categories for the concatenate" help="List of comma-separated key">
                    <expand macro="sanitize_query" />
                </param>
                <param argument="k" type="integer" value="20" label="Number of mutual nearest neighbors"/>
                <param argument="sigma" type="float" value="1" label="The bandwidth of the Gaussian smoothing kernel used to compute the correction vectors"/>
                <param argument="cos_norm_in" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Should cosine normalization be performed on the input data prior to calculating distances between cells?"/>
                <param argument="cos_norm_out" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Should cosine normalization be performed prior to computing corrected expression values?"/>
                <param argument="svd_dim" type="integer" value="" optional="true" label="Number of dimensions to use for summarizing biological substructure within each batch" help="If not set, biological components will not be removed from the correction vectors."/>
                <param argument="var_adj" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Adjust variance of the correction vectors?" help="This step takes most computing time."/>
                <param argument="compute_angle" type="boolean" truevalue="True" falsevalue="False" checked="false" label="compute the angle between each cellâ€™s correction vector and the biological subspace of the reference batch?"/>
                <param argument="mnn_order" type="text" value="" optional="true" label="The order in which batches are to be corrected" help="List of comma-separated key. If not set, datas are corrected sequentially">
                    <expand macro="sanitize_query" />
                </param>
                <param name="svd_mode" type="select" label="SVD mode">
                    <option value="svd">svd: SVD using a non-randomized SVD-via-ID algorithm</option>
                    <option value="rsvd" selected="true">rsvd: SVD using a randomized SVD-via-ID algorithm</option>
                    <option value="irlb">irlb: truncated SVD by implicitly restarted Lanczos bidiagonalization</option>
                </param>
            </when>
            <when value="pp.combat">
                <param argument="key" type="text" value="batch" label="Key to a categorical annotation from adata.obs that will be used for batch effect removal">
                    <expand macro="sanitize_query" />
                </param>
            </when>
            <when value="pp.scrublet">
                <param argument="batch_key" type="text" value="" optional="true" label="Batch key for the concatenate">
                    <expand macro="sanitize_query" />
                </param>
                <param argument="sim_doublet_ratio" type="float" value="2.0" label="Number of doublets to simulate relative to the number of observed transcriptomes"/>
                <param argument="expected_doublet_rate" type="float" value="0.05" label="The estimated doublet rate for the experiment"/>
                <param argument="stdev_doublet_rate" type="float" value="0.02" label="Uncertainty in the expected doublet rate"/>
                <param argument="synthetic_doublet_umi_subsampling" type="float" value="1.0" label="ate for sampling UMIs when creating synthetic doublets" help="f 1.0, each doublet is created by simply adding the UMI counts from two randomly sampled observed transcriptomes. For values less than 1, the UMI counts are added and then randomly sampled at the specified rate."/>
                <param name="knn_dist_metric" type="select" label="Distance metric used when finding nearest neighbors">
                    <expand macro="distance_metric_options"/>
                </param>
                <param argument="normalize_variance" type="boolean" truevalue="True" falsevalue="False" checked="true" label="normalize the data such that each gene has a variance of 1"/>
                <param argument="log_transform" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Whether to use log1p() to log-transform the data prior to PCA"/>
                <param argument="mean_center" type="boolean" truevalue="True" falsevalue="False" checked="false" label="If True, center the data such that each gene has a mean of 0"/>
                <param argument="n_prin_comps" type="integer" value="30" label="Number of principal components used to embed the transcriptomes prior to k-nearest-neighbor graph construction"/>
                <param argument="use_approx_neighbors" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Use approximate nearest neighbor method (annoy) for the KNN classifier"/>
                <param argument="get_doublet_neighbor_parents" type="boolean" truevalue="True" falsevalue="False" checked="false" label="If True, return (in .uns) the parent transcriptomes that generated the doublet neighbors of each observed transcriptome" help="This information can be used to infer the cell states that generated a given doublet state."/>
                <param argument="n_neighbors" type="integer" value="" optional="true" label="Number of neighbors used to construct the KNN graph of observed transcriptomes and simulated doublets"/>
                <param argument="threshold" type="float" value="" optional="true" label="Doublet score threshold for calling a transcriptome a doublet" help="If None, this is set automatically"/>
                <param name="random_state" type="integer" value="0" label="Initial state for doublet simulation and nearest neighbors"/>
            </when>
        </conditional>
        <expand macro="inputs_common_advanced"/>
    </inputs>
    <outputs>
        <expand macro="anndata_outputs"/>
    </outputs>
    <tests>
        <test expect_num_outputs="2">
            <!-- test 0 -->
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.regress_out"/>
                <param name="keys" value="cell_type"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sc.pp.regress_out"/>
                    <has_text_matching expression="keys=\['cell_type'\]"/>
                </assert_contents>
            </output>
            <output name="anndata_out" file="pp.regress_out.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <!--<test expect_num_outputs="2">
            < test 2 >
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.mnn_correct"/>
                <param name="reg_keys" value="cell_type"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.mnn_correct"/>
                <has_text_matching expression="keys='cell_type'"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.mnn_correct.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>-->
        <test expect_num_outputs="2">
            <!-- test 1 -->
            <param name="adata" value="blobs.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.combat"/>
                <param name="key" value="blobs"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sc.pp.combat"/>
                    <has_text_matching expression="key='blobs'"/>
                </assert_contents>
            </output>
            <output name="anndata_out" file="pp.combat.blobs.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
    </tests>
    <help><![CDATA[
Regress out unwanted sources of variation, using `pp.regress_out`
=================================================================

Regress out unwanted sources of variation, using simple linear regression. This is
inspired by Seurat's `regressOut` function in R.

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/stable/api/scanpy.pp.regress_out.html>`__

Correct batch effects by matching mutual nearest neighbors, using `external.pp.mnn_correct`
==================================================================================

This uses the implementation of mnnpy. Depending on do_concatenate, it returns AnnData objects in the
original order containing corrected expression values or a concatenated matrix or AnnData object.

Be reminded that it is not advised to use the corrected data matrices for differential expression testing.

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html>`__


Correct batch effects with ComBat function (`pp.combat`)
========================================================

Corrects for batch effects by fitting linear models, gains statistical power via an EB framework where information is borrowed across genes. This uses the implementation of ComBat

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.combat.html>`__


    ]]></help>
    <expand macro="citations"/>
</tool>
