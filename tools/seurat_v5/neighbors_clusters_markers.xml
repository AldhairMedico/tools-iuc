<tool id="seurat_neighbors_clusters_markers" name="Find neighbors, clusters and markers" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <expand macro="version_command"/>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
    ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_imports@
@CMD_read_inputs@

#if $method.method == 'FindNeighbors'
seurat_obj<-FindNeighbors(
    seurat_obj,
    #if $method.query != ''
    query = '$method.query',
    #end if
    #if $method.reduction != ''
    reduction = '$method.reduction',
    #end if
    #if $method.dims != ''
    dims = $method.dims,
    #end if
    distance.matrix = $method.distance_matrix,
    k.param = $method.k_param,
    return.neighbor = $method.return_neighbor,
    compute.snn = $method.compute_snn,
    #if $method.prune_snn != ''
    prune.snn = $method.prune_snn,
    #end if
    nn.method = '$method.nn_method.nn_method',
    #if $method.nn_method.nn_method == 'rann'
    nn.eps = $method.nn_method.nn_eps,
    #else if $method.nn_method.nn_method == 'annoy'
    annoy.metric = '$method.nn_method.annoy_metric',
    #end if
    l2.norm = $method.l2_norm,
    cache.index = $method.cache_index,
    #if $method.index != ''
    index = '$method.index',
    #end if
    n.trees = $method.n_trees
)

#else if $method.method == 'FindClusters'
seurat_obj<-FindClusters(
    seurat_obj,
    modularity.fxn = $method.modularity_fxn,
    resolution = $method.resolution,
    algorithm = $method.algorithm.algorithm,
    #if $method.algorithm.algorithm == 4
        #if $method.algorithm.initial_membership != ''
        initial.membership = $method.algorithm.initial_membership,
        #end if
        #if $method.algorithm.node_sizes != ''
        node.sizes = $method.algorithm.node_sizes,
        #end if
        method = '$method.algorithm.method_cluster',
    #end if
    n.start = $method.n_start,
    n.iter = $method.n_iter,
    random.seed = $method.random_seed
)

#else if $method.method == 'FindAllMarkers'
seurat_obj<-FindAllMarkers(
    seurat_obj,
    #if $method.assay != ''
    assay = '$method.assay',
    #end if
    #if $method.features != ''
        #set $features = (x.strip() for x in str($method.features).split(','))
        features = c($features),
    #end if
    logfc.threshold = $method.logfc_threshold,
    test.use = '$method.test_use.test_use',
    #if $method.test_use.test_use == 'negbinom'
        #if $method.test_use.latent_vars != ''
        latent.vars = '$method.test_use.latent_vars',
        #end if
        min.cells.feature = $method.test_use.min_cells_feature,
    #else if $method.test_use.test_use == 'poisson'
        #if $method.test_use.latent_vars != ''
        latent.vars = '$method.test_use.latent_vars',
        #end if
        min.cells.feature = $method.test_use.min_cells_feature,
    #else if $method.test_use.test_use =='LR'
        #if $method.test_use.latent_vars != ''
        latent.vars = '$method.test_use.latent_vars',
        #end if
    #else if $method.test_use.test_use == 'MAST'
        #if $method.test_use.latent_vars != ''
        latent.vars = '$method.test_use.latent_vars',
        #end if
    #else if $method.test_use.test_use == 'roc'
        return.thresh = $method.test_use.return_thresh,
    #end if
    slot = '$method.slot',
    min.pct = $method.min_pct,
    #if $method.min_diff_pct != ''
    min.diff.pct = $method.min_diff_pct,
    #end if
    only.pos = $method.only_pos,
    #if $method.max_cells_per_ident != ''
    max.cells.per.ident = $method.max_cells_per_ident,
    #end if
    random.seed = $method.random_seed,
    min.cells.group = $method.min_cells_group,
    #if $method.mean_fxn != ''
    mean.fxn = '$method.mean_fxn',
    #end if
    #if $method.fc_name != ''
    fc.name = '$method.fc_name',
    #end if
    base = $method.base,
    densify = $method.densify
)

#else if $method.method == 'FindMarkers'
seurat_obj<-FindMarkers(
    seurat_obj,
    slot = '$method.slot',
    #if $method.cells.cells == 'true'
    cells.1 = '$method.cells.cells_1',
    cells.2 = '$method.cells.cells_2',
    #end if
    #if $method.ident.ident == 'true'
    ident.1 = '$method.ident.ident_1',
        #if $method.ident.ident_2 != ''
        ident.2 = '$method.ident.ident_2',
        #end if
    #end if
    #if $method.features != ''
    #set $features = (x.strip() for x in str($method.features).split(','))
    features = c($features),
    #end if
    logfc.threshold = $method.logfc_threshold,
    test.use = '$method.test_use.test_use',
    #if $method.test_use.test_use == 'negbinom'
        #if $method.test_use.latent_vars != ''
        latent.vars = '$method.test_use.latent_vars',
        #end if
        min.cells.feature = $method.test_use.min_cells_feature,
    #else if $method.test_use.test_use == 'poisson'
        #if $method.test_use.latent_vars != ''
        latent.vars = '$method.test_use.latent_vars',
        #end if
        min.cells.feature = $method.test_use.min_cells_feature,
    #else if $method.test_use.test_use =='LR'
        #if $method.test_use.latent_vars != ''
        latent.vars = '$method.test_use.latent_vars',
        #end if
    #else if $method.test_use.test_use == 'MAST'
        #if $method.test_use.latent_vars != ''
        latent.vars = '$method.test_use.latent_vars',
        #end if
    #end if
    min.pct = $method.min_pct,
    #if $method.min_diff_pct != ''
    min.diff.pct = $method.min_diff_pct,
    #end if
    only.pos = $method.only_pos,
    #if $method.max_cells_per_ident != ''
    max.cells.per.ident = $method.max_cells_per_ident,
    #end if
    random.seed = $method.random_seed,
    min.cells.group = $method.min_cells_group,
    #if $method.fc_results != ''
    fc.results = '$method.fc_results',
    #end if
    densify = $method.densify
)

#end if

@CMD_rds_write_outputs@

]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="input_rds"/>
        <conditional name="method">
            <param name="method" type="select" label="Method used">
                <option value="FindNeighbors">Compute nearest neighbors with 'FindNeighbors'</option>
                <option value="FindClusters"> Identify cell clusters with 'FindClusters'</option>
                <option value="FindAllMarkers">Identify marker genes with 'FindAllMarkers'</option>
                <option value="FindMarkers"> Identify marker genes for specific groups with 'FindMarkers'</option>
            </param>
            <when value="FindNeighbors">
                <param name="query" type="text" optional="true" value="" label="Matrix of data to query against object"/>
                <param name="reduction" type="text" optional="true" value="pca" label="Reduction to use as input for building the (S)NN"/>
                <param name="dims" type="text" optional="true" value="1:10" label="Dimensions of reduction to use as input"/>
                <param name="distance_matrix" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Use a distance matrix"/>
                <param name="k_param" type="integer" value="20" label="Set k for k-nearest neighbors"/>
                <param name="return_neighbor" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Return result as neighbor object (do not use with distance matrix or when computing SNN)"/>
                <param name="compute_snn" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Compute the shared nearest neighbor (SNN) graph"/>
                <param name="prune_snn" type="float" optional="true" value="" min="0" max="1" label="Set cutoff for Jaccard index when computing overlap for SNN (0 no pruning, 1 prune everything)"/>
                <conditional name="nn_method">
                    <param name="nn_method" type="select" label="Method for finding nearest neighbors">
                        <option value="rann">rann</option>
                        <option value="annoy" selected="true">annoy</option>
                    </param>
                    <when value="rann">
                        <param name="nn_eps" type="float" value="0.0" label="Set error bound for nearest neighbor search using RANN"/>
                    </when>
                    <when value="annoy">
                        <param name="annoy_metric" type="select" label="Distance metric for annoy method">
                            <option value="euclidean" selected="true">euclidean</option>
                            <option value="cosine">cosine</option>
                            <option value="manhattan">manhattan</option>
                            <option value="hamming">hamming</option>
                        </param>
                    </when>
                </conditional>
                <param name="n_trees" type="integer" value="50" label="Number of trees for nearest neighbor search"/>
                <param name="l2_norm" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Take l2Norm of data"/>
                <param name="cache_index" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Include cached index in returned neighbor object (can use if return.neighbor is true)"/>
                <param name="index" type="text" optional="true" value="" label="Use precomputed index"/>
            </when>
            <when value="FindClusters">
                <param name="modularity_fxn" type="select" label="Select modularity function">
                    <option value="1" selected="true">standard</option>
                    <option value="2">alternative</option>
                </param>
                <param name="resolution" type="float" value="0.8" label="Resolution"/>
                <conditional name="algorithm">
                    <param name="algorithm" type="select" label="Algorithm for modularity optimization">
                        <option value="1" selected="true">Original Louvain</option>
                        <option value="2">Louvain with multilevel refinement"</option>
                        <option value="3">SLM</option>
                        <option value="4">Leiden</option>
                    </param>
                    <when value="4">
                        <param name="initial_membership" type="integer" optional="true" value="" label="Set initial membership when using Python leidenalg function, defaults to singleton partition"/>
                        <param name="node_sizes" type="integer" optional="true" value="1" label="Set node size when using Python leidenalg function"/>
                        <param name="method_cluster" type="select" label="Method for leiden" help="matrix is fast for small data, enable igraph for larger data">
                            <option value="matrix" selected="true">matrix</option>
                            <option value="igraph">igraph</option>
                        </param>
                    </when>
                    <when value="1">
                    </when>
                    <when value="2">
                    </when>
                    <when value="3">
                    </when>
                </conditional>
                <param name="n_start" type="integer" value="10" label="Number of random starts"/>
                <param name="n_iter" type="integer" value="10" label="Maximal number of iterations per random start"/>
                <param name="random_seed" type="integer" value="0" label="Set a random seed"/>
                <param name="group_singletons" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Group singletons into nearest cluster" help="Set to false to create a cluster for all singletons"/>
                <param name="clusters_out" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Output cluster data"/>
            </when>
            <when value="FindAllMarkers">
                <param argument="assay" type="text" value="" optional="true" label="Name of Assay to use in differential expression testing"/>
                <param name="features" type="text" optional="true" value="" label="Genes to test (default is all genes)"/>
                <param name="logfc_threshold" type="float" value="0.1" label="Minimum log-fold difference to test"/>
                <conditional name="test_use">
                    <param name="test_use" type="select" label="Select test to run">
                        <option value="wilcox" selected="true">wilcox</option>
                        <option value="wilcox_limma">wilcox_limma</option>
                        <option value="bimod">bimod</option>
                        <option value="roc">roc</option>
                        <option value="t">t</option>
                        <option value="negbinom">negbinom</option>
                        <option value="poisson">poisson</option>
                        <option value="LR">LR</option>
                        <option value="MAST">MAST</option>
                        <option value="DESeq2">DESeq2</option>
                    </param>
                    <when value="wilcox"></when>
                    <when value="wilcox_limma"></when>
                    <when value="bimod"></when>
                    <when value="roc">
                        <param name="return_thresh" type="float" value="0.01" label="Only return markers with a p-value below or power above this threshold (if the test is ROC)"/>
                    </when>
                    <when value="t"></when>
                    <when value="negbinom">
                        <param name="latent_vars" type="text" optional="true" value="" label="Select variables to test when using LR, negbinom, poisson, or MAST methods"/>
                        <param name="min_cells_feature" type="integer" value="3" label="Minimum number of cells expressing the feature in at least one cluster (for poisson and negative bionomial tests)"/>
                    </when>
                    <when value="poisson">
                        <param name="latent_vars" type="text" optional="true" value="" label="Select variables to test when using LR, negbinom, poisson, or MAST methods"/>
                        <param name="min_cells_feature" type="integer" value="3" label="Minimum number of cells expressing the feature in at least one cluster (for poisson and negative bionomial tests)"/>
                    </when>
                    <when value="LR">
                        <param name="latent_vars" type="text" optional="true" value="" label="Select variables to test when using LR, negbinom, poisson, or MAST methods"/>
                    </when>
                    <when value="MAST">
                        <param name="latent_vars" type="text" optional="true" value="" label="Select variables to test when using LR, negbinom, poisson, or MAST methods"/>
                    </when>
                    <when value="DESeq2"></when>
                </conditional>
                <param name="slot" type="text" value="data" label="Slot to pull data from (data, counts, scale.data) (set to counts for negbinom, poisson or DESeq2)"/>
                <param name="min_pct" type="float" value="0.01" label="Minimum percentage of cells genes must be present in to be tested"/>
                <param name="min_diff_pct" type="float" optional="true" value="" label="Minimum difference in percentage of expression between groups for genes to be tested, defaults to -Inf"/>
                <param name="only_pos" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Only return positive markers"/>
                <param name="max_cells_per_ident" type="integer" optional="true" value="" label="Downsample each identity class to a max number of cells, defaults to Inf (no downsampling)"/>
                <param name="random_seed" type="integer" optional = "true" value="1" label="Set a random seed for downsampling"/>
                <param name="min_cells_group" type="integer" value="3" label="Minimum number of cells in one group"/>
                <param name="mean_fxn" type="text" optional="true" value="" label="Function to use for fold change or average difference calculation (default depends on slot)"/>
                <param name="fc_name" type="text" optional="true" value="" label="Choose a name for the fold change, average difference, or custom function column"/>
                <param name="base" type="integer" value="2" label="Base with respect to which logarithms are computed"/>
                <param name="densify" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Convert to dense matrix before running DE test"/>
                <param name="markers_out" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Output marker data table"/>
            </when>
            <when value="FindMarkers">
                <param name="slot" type="text" value="data" label="Slot to pull data from (set to counts for negbinom, poisson or DESeq2)"/>
                <conditional name="cells">
                    <param name="cells" type="select" label="Compare markers for two groups of cells">
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </param>
                    <when value="true">
                        <param name="cells_1" type="text" optional="true" value="" label="Vector of cell names for group 1"/>
                        <param name="cells_2" type="text" optional="true" value="" label="Vector of cell names for group 2"/>
                    </when>
                    <when value="false">
                    </when>
                </conditional>
                <conditional name="ident">
                    <param name="ident" type="select" label="Compare markers between clusters of cells">
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </param>
                    <when value="true">
                        <param name="ident_1" type="text" optional="true" value="" label="Identity class to define markers for (e.g. cluster numbers)"/>
                        <param name="ident_2" type="text" optional="true" value="" label="Second identity class to compare (e.g. cluster numbers). Leave blank to compare against all other clusters."/>
                    </when>
                    <when value="false">
                    </when>
                </conditional>
                <param name="features" type="text" optional="true" value="" label="Genes to test (default is all genes)"/>
                <param name="logfc_threshold" type="float" value="0.1" label="Minimum log-fold difference to test"/>
                <conditional name="test_use">
                    <param name="test_use" type="select" label="Select test to run">
                        <option value="wilcox" selected="true">wilcox</option>
                        <option value="wilcox_limma">wilcox_limma</option>
                        <option value="bimod">bimod</option>
                        <option value="roc">roc</option>
                        <option value="t">t</option>
                        <option value="negbinom">negbinom</option>
                        <option value="poisson">poisson</option>
                        <option value="LR">LR</option>
                        <option value="MAST">MAST</option>
                        <option value="DESeq2">DESeq2</option>
                    </param>
                    <when value="wilcox"></when>
                    <when value="wilcox_limma"></when>
                    <when value="bimod"></when>
                    <when value="roc"></when>
                    <when value="t"></when>
                    <when value="negbinom">
                        <param name="latent_vars" type="text" optional="true" value="" label="Select variables to test when using LR, negbinom, poisson, or MAST methods"/>
                        <param name="min_cells_feature" type="integer" value="3" label="Minimum number of cells expressing the feature in at least one cluster (for poisson and negative bionomial tests)"/>
                    </when>
                    <when value="poisson">
                        <param name="latent_vars" type="text" optional="true" value="" label="Select variables to test when using LR, negbinom, poisson, or MAST methods"/>
                        <param name="min_cells_feature" type="integer" value="3" label="Minimum number of cells expressing the feature in at least one cluster (for poisson and negative bionomial tests)"/>
                    </when>
                    <when value="LR">
                        <param name="latent_vars" type="text" optional="true" value="" label="Select variables to test when using LR, negbinom, poisson, or MAST methods"/>
                    </when>
                    <when value="MAST">
                        <param name="latent_vars" type="text" optional="true" value="" label="Select variables to test when using LR, negbinom, poisson, or MAST methods"/>
                    </when>
                    <when value="DESeq2"></when>
                </conditional>
                <param name="min_pct" type="float" value="0.01" label="Minimum percentage of cells genes must be present in to be tested"/>
                <param name="min_diff_pct" type="float" optional="true" value="" label="Minimum difference in percentage of expression between groups for genes to be tested, defaults to -Inf"/>
                <param name="only_pos" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Only return positive markers"/>
                <param name="max_cells_per_ident" type="integer" optional="true" value="" label="Downsample each identity class to a max number of cells, defaults to Inf (no downsampling)"/>
                <param name="random_seed" type="integer" optional="true" value="1" label="Set a random seed for downsampling"/>
                <param name="min_cells_group" type="integer" value="3" label="Minimum number of cells in one group"/>
                <param name="fc_results" type="text" optional="true" value="" label="Output for FoldChange results"/>
                <param name="densify" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Convert to dense matrix before running DE test"/>
                <param name="markers_out" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Output marker data table"/>
            </when>
        </conditional>
        <expand macro="inputs_common_advanced"/>
    </inputs>
    <outputs>
        <expand macro="seurat_outputs"/>
        <expand macro="markers_out"/>
    </outputs>
    <tests>
        <test expect_num_outputs="2">
            <!-- test1: FindNeighbors -->
            <param name="seurat_rds" value="pca.rds"/>
            <conditional name="method">
                <param name="method" value="FindNeighbors"/>
                <param name="reduction" value="pca"/>
                <param name="dims" value="1:10"/>
                <param name="distance_matrix" value="FALSE"/>
                <param name="k_param" value="20"/>
                <param name="return_neighbor" value="FALSE"/>
                <param name="compute_snn" value="FALSE"/>
                <conditional name="nn_method">
                    <param name="nn_method" value="annoy"/>
                    <param name="annoy_metric" value="euclidean"/>
                </conditional>
                <param name="n_trees" value="50"/>
                <param name="l2_norm" value="FALSE"/>
                <param name="cache_index" value="FALSE"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true"/>
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="FindNeighbors"/>
                </assert_contents>
            </output>
            <output name="rds_out" file="neighbors.rds" ftype="rds"/>
        </test>
        <test expect_num_outputs="2">
            <!-- test2: FindClusters -->
            <param name="seurat_rds" value="neighbors.rds"/>
            <conditional name="method">
                <param name="method" value="FindClusters"/>
                <param name="modularity_fxn" value="1"/>
                <param name="resolution" value="0.8"/>
                <conditional name="algorithm">
                    <param name="algorithm" value="1"/>
                </conditional>
                <param name="n_start" value="10"/>
                <param name="n_iter" value="10"/>
                <param name="random_seed" value="0"/>
                <param name="group_singletons" value="TRUE"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true"/>
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="FindClusters"/>
                </assert_contents>
            </output>
            <output name="rds_out" file="clusters.rds" ftype="rds"/>
        </test>
        <test expect_num_outputs="2">
            <!-- test3: FindAllMarkers -->
            <param name="seurat_rds" value="clusters.rds"/>
            <conditional name="method">
                <param name="method" value="FindAllMarkers"/>
                <param name="assay" value="RNA"/>
                <param name="logfc_threshold" value="0.1"/>
                <param name="slot" value="data"/>
                <conditional name="test_use">
                    <param name="test_use" value="wilcox"/>
                </conditional>
                <param name="min_pct" value="0.01"/>
                <param name="only_pos" value="FALSE"/>
                <param name="random_seed" value="1"/>
                <param name="min_cells_group" value="3"/>
                <param name="base" value="2"/>
                <param name="densify" value="FALSE"/>
                <param name="markers_out" value="FALSE"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true"/>
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="FindAllMarkers"/>
                </assert_contents>
            </output>
            <output name="rds_out" file="allmarkers.rds" ftype="rds"/>
        </test>
        <test expect_num_outputs="2">
            <!-- test4: FindMarkers -->
            <param name="seurat_rds" value="clusters.rds"/>
            <conditional name="method">
                <param name="method" value="FindMarkers"/>
                <param name="slot" value="data"/>
                <conditional name="cells">
                    <param name="cells" value="false"/>
                </conditional>
                <conditional name="ident">
                    <param name="ident" value="true"/>
                    <param name="ident_1" value="0"/>
                    <param name="ident_2" value="1"/>
                </conditional>
                <param name="logfc_threshold" value="0.1"/>
                <conditional name="test_use">
                    <param name="test_use" value="wilcox"/>
                </conditional>
                <param name="min_pct" value="0.01"/>
                <param name="only_pos" value="FALSE"/>
                <param name="random_seed" value="1"/>
                <param name="min_cells_group" value="3"/>
                <param name="densify" value="FALSE"/>
                <param name="markers_out" value="FALSE"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true"/>
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="FindMarkers"/>
                </assert_contents>
            </output>
            <output name="rds_out" file="markers.rds" ftype="rds"/>
        </test>
    </tests>
    <help><![CDATA[
Seurat
======

Seurat is an R package designed for QC, analysis, and exploration of single-cell RNA-seq data. 

Seurat aims to enable users to identify and interpret sources of heterogeneity from single-cell transcriptomic measurements, and to integrate diverse types of single-cell data.

FindNeighbors
=============

Compute the k.param nearest neighbors for a given dataset. 

Can also optionally (via compute.SNN), construct a shared nearest neighbor graph by calculating the neighborhood overlap (Jaccard index) between every cell and its k.param nearest neighbors.

More details on the `seurat documentation
<https://satijalab.org/seurat/reference/findneighbors>`__

FindClusters
============

Identify clusters of cells by a shared nearest neighbor (SNN) modularity optimization based clustering algorithm. 

First calculate k-nearest neighbors and construct the SNN graph. Then optimize the modularity function to determine clusters. 

More details on the `seurat documentation
<https://satijalab.org/seurat/reference/findclusters>`__

FindMarkers
===========

Find markers (differentially expressed genes) for identity classes

Methods:

"wilcox" : Identifies differentially expressed genes between two groups of cells using a Wilcoxon Rank Sum test (default); will use a fast implementation by Presto if installed

"wilcox_limma" : Identifies differentially expressed genes between two groups of cells using the limma implementation of the Wilcoxon Rank Sum test; set this option to reproduce results from Seurat v4

"bimod" : Likelihood-ratio test for single cell gene expression, (McDavid et al., Bioinformatics, 2013)

"roc" : Identifies 'markers' of gene expression using ROC analysis. For each gene, evaluates (using AUC) a classifier built on that gene alone, to classify between two groups of cells. An AUC value of 1 means that expression values for this gene alone can perfectly classify the two groupings (i.e. Each of the cells in cells.1 exhibit a higher level than each of the cells in cells.2). An AUC value of 0 also means there is perfect classification, but in the other direction. A value of 0.5 implies that the gene has no predictive power to classify the two groups. Returns a 'predictive power' (abs(AUC-0.5) * 2) ranked matrix of putative differentially expressed genes.

"t" : Identify differentially expressed genes between two groups of cells using Student's t-test.

"negbinom" : Identifies differentially expressed genes between two groups of cells using a negative binomial generalized linear model. Use only for UMI-based datasets

"poisson" : Identifies differentially expressed genes between two groups of cells using a poisson generalized linear model. Use only for UMI-based datasets

"LR" : Uses a logistic regression framework to determine differentially expressed genes. Constructs a logistic regression model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test.

"MAST" : Identifies differentially expressed genes between two groups of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST package to run the DE testing.

"DESeq2" : Identifies differentially expressed genes between two groups of cells based on a model using DESeq2 which uses a negative binomial distribution (Love et al, Genome Biology, 2014).This test does not support pre-filtering of genes based on average difference (or percent detection rate) between cell groups. However, genes may be pre-filtered based on their minimum detection rate (min.pct) across both cell groups. To use this method, please install DESeq2, using the instructions at https://bioconductor.org/packages/release/bioc/html/DESeq2.html

More details on the `seurat documentation
<https://satijalab.org/seurat/reference/findmarkers>`__

    ]]></help>
    <expand macro="citations"/>
</tool>